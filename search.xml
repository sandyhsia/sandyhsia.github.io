<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>12.7 - 虚基类</title>
      <link href="//blog/2020/06/learncpp-cn-127-virtual-base-class.html"/>
      <url>//blog/2020/06/learncpp-cn-127-virtual-base-class.html</url>
      
        <content type="html"><![CDATA[<p>在第十一课的最后一章——多重继承中，我们结束了对“钻石问题”的讨论。在本节中，我们将继续这个讨论。</p><p>注意: 此部分是一个高级主题，如果需要可以跳过或略读。</p><h2 id="钻石问题（The-diamond-problem）"><a href="#钻石问题（The-diamond-problem）" class="headerlink" title="钻石问题（The diamond problem）"></a>钻石问题（The diamond problem）</h2><p>下面是我们上一课的例子(带有一些构造函数)，说明了钻石问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管你可能期望得到一个像这样的继承图:<br><img src="/image/virtual-base-0.png" alt=""></p><p>如果您要创建一个copyier类对象，默认情况下您将得到PoweredDevice类的两个副本——一个来自Printer，一个来自Scanner。其结构如下:<br><img src="/image/virtual-base-1.png" alt=""></p><p>我们可以创建一个简短的例子来演示它:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 它将会输出以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PoweredDevice: 3</span><br><span class="line">Scanner: 1</span><br><span class="line">PoweredDevice: 3</span><br><span class="line">Printer: 2</span><br></pre></td></tr></table></figure><p>如您所见，PoweredDevice构造了两次。</p><p>虽然这通常是需要的，但有时您可能希望扫描仪和打印机只共享PoweredDevice的一个副本。</p><h2 id="虚拟基类-Virtual-base-classes"><a href="#虚拟基类-Virtual-base-classes" class="headerlink" title="虚拟基类 (Virtual base classes)"></a>虚拟基类 (Virtual base classes)</h2><p>要共享基类，只需在派生类的继承列表中插入“virtual”关键字。这将创建所谓的虚拟基类，这意味着只有一个基对象。基对象在继承树中的所有对象之间共享，并且只构造一次。下面是一个例子(为了简单起见没有构造函数)，展示了如何使用virtual关键字创建一个共享的基类:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，当您创建Copyier类对象时，您将在Copyier内只获得一个的PoweredDevice副本，该副本将由Scanner和Printer共享。</p><p>但是，这又带来了一个问题: 如果Scanner和Printer共享一个PoweredDevice基类，那么谁负责创建它? 事实证明，答案是Copier。Copier构造函数负责创建PoweredDevice。因此，这是一次允许Copier直接调用非直接父类构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power), <span class="comment">// PoweredDevice is constructed here</span></span><br><span class="line">        Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时上述例子中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PoweredDevice: 3</span><br><span class="line">Scanner: 1</span><br><span class="line">Printer: 2</span><br></pre></td></tr></table></figure><p>如您所见，PoweredDevice只构造一次。</p><p>有几个细节，如果我们不提，我们也许会疏忽。</p><p>首先，虚拟基类总是在非虚拟基类之前创建，这确保了所有的基在它们的派生类之前创建。</p><p>其次，请注意Scanner和Printer构造函数仍然调用PoweredDevice构造函数。当创建Copyier的实例时，这些构造函数调用将被忽略，因为Copyier负责创建PoweredDevice，而不是Scanner或Printer。但是，如果我们要创建Scanner或Printer的实例，将使用那些构造函数调用，并应用常规继承规则。</p><p>第三，如果一个类继承了一个或多个具有虚拟父类的类，则派生最多的类负责构造虚拟基类。在本例中，Copier继承Printer和Scanner，这两个都有一个PoweredDevice虚拟基类。Copyier是派生最多的类，负责创建PoweredDevice。注意，即使在单一继承情况下也是如此: 如果Copier是从Printer单独继承的，而Printer实际上是从PoweredDevice继承的，那么Copier仍然负责创建PoweredDevice。</p><p>第四，所有继承虚基类的类都将拥有一个虚表，即使它们通常没有虚表，也会因此增加一个指针。</p><p>因为“Scanner”和“Printer”实际上派生自“PoweredDevice”，所以“Copier”将只是“PoweredDevice”的一个子对象。Scanner和Printer都需要知道如何找到单个PoweredDevice子对象，这样它们就可以访问它的成员 (因为毕竟它们是从它派生出来的)。这通常通过一些虚拟表魔术(实际上存储了从每个子类到PoweredDevice子对象的偏移量) 来完成。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.5 - 虚函数表</title>
      <link href="//blog/2020/06/learncpp-cn-125-virtual-table.html"/>
      <url>//blog/2020/06/learncpp-cn-125-virtual-table.html</url>
      
        <content type="html"><![CDATA[<p>为了实现虚函数，c++使用了一种特殊的后期绑定形式，称为虚表。虚表是用于以动态 / 后期绑定方式解析函数调用的函数的查找表。虚表有时使用其他名称，如“vtable”、“virtual function table”、“virtual method table”或“dispatch table”。</p><p>因为了解虚函数表的工作方式对于使用虚函数来说并不是必需的，所以这一节可以看作是可选的阅读。</p><p>虚函数表实际上非常简单，虽然用文字描述有点复杂。首先，每个使用虚函数的类(或派生自使用虚函数的类)都有自己的虚函数表。这个表就是编译器在编译时设置的一个静态数组。虚函数表中的每一个条目包含着该类对象可以调用的每一个虚函数。这个表中的每个条目都是一个函数指针，指向该类可访问的派生程度最高(most-derived)的函数。</p><p>其次，编译器还向基类添加了一个隐藏指针，我们将其称为*__vptr。在创建类实例时，*__vptr自动就被设置了，以便它指向该类的虚表。*this指针实际上是编译器用来解析自引用的一个函数参数，与*this指针不同，*__ vptr是一个真正的指针。因此，它的存在使分配的每个类对象的大小，都比应有的大小要多出一个指针的空间。这也意味着*__vptr是由派生类自动继承的，这一点很重要。</p><p>到目前为止，你可能对这些东西是如何组合在一起的感到困惑，所以让我们看一个简单的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为这里有3个类，编译器将设置3个虚表: 一个用于基表，一个用于D1，一个用于D2。</p><p>编译器还向使用虚函数的最基类添加一个隐藏指针。虽然编译器会自动这样做，我们会把它放在下一个例子，以显示它是在哪里添加的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当创建一个类对象时，*__ vptr被设置为指向该类的虚表。例如，当创建了一个Base类型的对象时，*__ vptr被设置为指向Base的虚表。当构造D1或D2类型的对象时，*__ vptr被设置为分别指向D1或D2的虚表。</p><p>现在，让我们讨论一下这些虚拟表是如何被填上的。因为这里只有两个虚函数，每个虚表将有两个条目(一个用于function1()，另一个用于function2())。请记住，当这些虚表被填满时，每个条目都填满了该类类型的对象可以调用的派生程度最高的函数。</p><p>基本对象的虚表很简单。Base类型的对象只能访问Base的成员。Base不能访问D1或D2函数。因此，function1的入口指向Base::function1()，而function2的入口指向Base::function2()。</p><p>D1的虚表稍微复杂一些。类型D1的对象可以访问D1和Base的成员。但是，D1已经覆盖了function1()，使得D1::function1()比Base::function1()更派生 (more derived) 。因此，function1的条目指向D1::function1()。D1没有覆盖function2()，因此function2的条目将指向Base::function2()。</p><p>D2的虚表类似于D1，除了function1的条目指向Base::function1()，而function2的条目指向D2::function2()。</p><p>这是一张图表:<br><img src="/image/virtual-table.png" alt=""></p><p>尽管这个图看起来有点疯狂，但它确实非常简单: 每个类中的*__ vptr指向该类的虚表。虚表中的条目指向该类的函数对象的派生程度最高的版本。</p><p>考虑一下当我们创建一个D1类型的对象时会发生什么:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为d1是D1对象，d1将它的*__vptr设置为D1的虚表。</p><p>现在，让我们设置一个指向D1的Base指针:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，因为dPtr是一个基指针，所以它只指向d1的基部分。但是，还要注意，*__ vptr位于类的基部分，因此dPtr可以访问这个指针。最后，请注意dPtr-&gt;__vptr指向D1虚表! 因此，即使dPtr的类型是Base，它仍然可以访问D1的虚表(通过__vptr)。</p><p>那么，当我们尝试调用dPtr-&gt;function1()时会发生什么呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line">    dPtr-&gt;function1();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，程序认识到function1()是一个虚函数。其次，程序使用dPtr-&gt; vptr来访问D1的虚拟表。第三，查找function1()调用D1的虚表的版本。这已经设置为D1::function1()。因此，dPtr-&gt;function1()解析为D1::function1()!</p><p>现在，您可能会说，“但是如果dPtr真的指向一个基对象而不是D1对象会怎么样呢?”它还会调用D1::function1()吗?”答案是否定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Base *bPtr = &amp;b;</span><br><span class="line">    bPtr-&gt;function1();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，当创建b时，vptr指向Base的虚表，而不是D1的虚表。因此，bPtr-&gt;__vptr也将指向Base的虚拟表。function1()的虚表条目指向Base::function1()。因此，bPtr-&gt;function1()解析为Base::function1()，这是派生程度最高的function1()版本，基对象应该能够调用它。</p><p>通过使用这些表，编译器和程序能够确保函数调用解析到适当的虚函数，即使您只使用一个指针或对基类的引用!</p><p>调用虚函数比调用非虚函数慢，原因如下: 首先，我们必须使用*__vptr来访问适当的虚表。其次，我们必须为虚表建立索引，以找到要调用的正确函数。只有这样我们才能调用这个函数。因此，我们必须执行3步操作才能找到要调用的函数，而不是对普通的间接函数调用时所执行的2步操作，或者对直接函数调用时所执行的1步操作。然而，对于现代计算机来说，这些额外的时间通常是微不足道的。</p><p>同样需要提醒的是，任何使用虚函数的类都有一个 __vptr，因此该类的每个对象都将比应有的大小再大一个指针的空间。虚拟函数非常强大，但是它们也有性能代价。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.4 - 早绑定和迟绑定</title>
      <link href="//blog/2020/06/learncpp-cn-124-early-late-binding.html"/>
      <url>//blog/2020/06/learncpp-cn-124-early-late-binding.html</url>
      
        <content type="html"><![CDATA[<p>在这节课和下节课中，我们将进一步了解虚拟函数是如何实现的。虽然这些信息对于有效地使用虚拟函数并不是严格必需的，但是它很有趣。不过，你可以把这两部分都当作可选阅读。</p><p>当一个c++程序被执行时，它按顺序执行，从main()的顶部开始。当遇到函数调用时，执行点会跳转到被调用函数的开头。CPU是如何做到这一点的?</p><p>编译程序时，编译器将c++程序中的每条语句转换成一行或多行机器语言。机器语言的每一行都有它自己的唯一顺序地址。这对于函数来说没有什么不同——当遇到一个函数时，它被转换成机器语言并给出下一个可用的地址。因此，每个函数都以唯一的地址结束。</p><p>绑定 (binding) 是指用于将标识符 (如变量和函数名) 转换为地址的过程。虽然绑定同时用于变量和函数，但在本节课中，我们将重点讨论函数绑定。</p><h2 id="早绑定-Early-binding"><a href="#早绑定-Early-binding" class="headerlink" title="早绑定 (Early binding)"></a>早绑定 (Early binding)</h2><p>编译器遇到的大多数函数调用都是直接的函数调用。直接函数调用是直接调用函数的语句。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValue(<span class="number">5</span>); <span class="comment">// This is a direct function call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接的函数调用可以使用称为早期绑定的进程来解决。早期绑定 (也称为静态绑定) 意味着编译器 (或链接器) 能够直接将标识符名称 (如函数或变量名) 与机器地址相关联。请记住，所有函数都有唯一的地址。因此，当编译器(或链接器)遇到一个函数调用时，它会用一条机器语言指令替换该函数调用，该指令告诉CPU跳转到函数的地址。</p><p>让我们看看一个使用早期绑定的简单计算器程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the target function directly using early binding</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: result = add(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: result = subtract(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: result = multiply(x, y); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为add()、subtract()和multiply()都是直接的函数调用，所以编译器将使用早期绑定来解析add()、subtract()和multiply()函数调用。编译器将用一条指令替换add()函数调用，这条指令告诉CPU跳转到add()函数的地址。对于subtract()和multiply()同样适用。</p><h2 id="迟绑定-Late-Binding"><a href="#迟绑定-Late-Binding" class="headerlink" title="迟绑定 (Late Binding)"></a>迟绑定 (Late Binding)</h2><p>在某些程序中，直到运行时(程序运行时)才知道将调用哪个函数。这称为后期绑定(或动态绑定)。在c++中，获得后期绑定的一种方法是使用函数指针。简单回顾一下函数指针，函数指针是一种指向函数而不是变量的指针。函数指针指向的函数，可以被通过在函数指针上使用函数调用操作符 (()) 来调用。</p><p>例如，下面的代码可以这样调用add()函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a function pointer and make it point to the add function</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pFcn(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// add 5 + 3</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数指针调用函数也称为间接函数调用。下面的计算器程序，除了使用了一个函数指针而不是直接的函数调用之外，在功能上与上面的计算器例子相同:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a function pointer named pFcn (yes, the syntax is ugly)</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set pFcn to point to the function the user chose</span></span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: pFcn = add; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: pFcn = subtract; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: pFcn = multiply; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Call the function that pFcn is pointing to with x and y as parameters</span></span><br><span class="line">    <span class="comment">// This uses late binding</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; pFcn(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，我们没有直接调用add()、subtract()或multiply()函数，而是将pFcn设置为指向我们希望调用的函数，然后通过该指针调用函数。编译器无法使用早期绑定来解析调用pFcn(x, y)的函数，因为它无法判断在编译时pFcn将指向哪个函数!</p><p>后期绑定的效率稍低一些，因为它涉及额外的间接调用。通过早期绑定，CPU可以直接跳转到函数的地址。但是如果是使用后期绑定，程序必须读取指针中保存的地址，然后跳转到该地址。这涉及一个额外的步骤，使它稍微慢一些。但是，后期绑定的优点是，它比早期绑定更灵活，因为直到运行时才需要决定调用哪个函数。</p><p>在下一课中，我们将了解如何使用后期绑定来实现虚函数。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.2a - 覆盖和最终说明符，以及协变返回类型</title>
      <link href="//blog/2020/06/learncpp-cn-122a-specifiers-and-return-type.html"/>
      <url>//blog/2020/06/learncpp-cn-122a-specifiers-and-return-type.html</url>
      
        <content type="html"><![CDATA[<p>为了解决继承的一些常见问题，c++11 在 c++中添加了两个特殊的标识符: override 和 final。注意，这些标识符不是关键字——它们是在特定上下文中具有特殊含义的普通标识符。</p><p>虽然final并不是经常使用，但是override是一个非常好的补充，您应该经常使用它。在这节课中，我们将看一下这两种情况，以及虚函数重写返回类型必须匹配的规则的一个例外。</p><h2 id="覆盖说明符-override"><a href="#覆盖说明符-override" class="headerlink" title="覆盖说明符 (override)"></a>覆盖说明符 (override)</h2><p>正如我们在前一课中提到的，派生类虚函数只有在其签名和返回类型完全匹配时才被认为是重写。这可能会导致无意的问题，而原本打算覆盖的函数实际上并不是写成的这样。</p><p>考虑下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">A &amp;rBase = b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为rBase是对B对象的A引用，所以这里的目的是使用虚函数来访问B::getName1()和B::getName2()。但是，因为B::getName1()接受一个不同的参数(一个短整型而不是一个整型)，所以它不被认为是对a::getName1()的覆盖。更狡猾的是，因为B::getName2()是const，而A::getName2()不是，B::getName2()不被认为是对A::getName2()的覆盖。</p><p>因此，这个程序打印:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>在这个特别的例子中，因为A和B只是打印它们的名字，很容易看出我们把重写搞砸了，并且调用了错误的虚函数。但是，在更复杂的程序中，函数有未打印的行为或返回值，这样的问题很难调试。</p><p>为了帮助解决函数的重写问题，c++ 11引入了重写 (覆盖, override) 说明符。重写说明符可以应用于任何重写函数，方法是将说明符放在const要去的相同位置。如果函数没有覆盖基类函数(或应用于非虚函数)，编译器会将该函数标记为错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, function is an override of A::getName3(int)</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序产生了两个编译错误:一个用于B::getName1()，另一个用于B::getName2()，因为它们都没有覆盖先前的函数。B::getName3()会覆盖A::getName3()，因此不会为该行产生错误。</p><p>使用覆盖说明符不会导致性能损失，而且它有助于避免意外错误。因此，我们强烈建议在您编写的每个虚函数重写中使用它，以确保您确实重写了您认为已经重写的函数。</p><blockquote><p>规则: 将重写说明符 (override) 应用于您编写的每个预期的重写函数。</p></blockquote><h2 id="最终说明符-final"><a href="#最终说明符-final" class="headerlink" title="最终说明符 (final)"></a>最终说明符 (final)</h2><p>在某些情况下，您可能不希望别人能够覆盖一个虚函数，或者从一个类继承。最后的说明符可以用来告诉编译器强制执行它。如果用户试图覆盖已指定为final的函数或类，编译器将给出一个编译错误。</p><p>在我们想要限制用户重写函数的情况下，最终的说明符是在相同的地方使用覆盖说明符，就像这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，B::getName()覆盖了A::getName()，这是可以的。但是B::getName()有最终的说明符，这意味着对该函数的任何进一步重写都应该被认为是一个错误。确实，C::getName()试图覆盖B::getName()(这里的覆盖说明符不相关，只是为了更好的实践)，所以编译器会给出一个编译错误。</p><p>在我们想要防止从类继承的情况下，最终说明符 (final) 也可以在类名后面应用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A <span class="comment">// note use of final specifier here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，类B被声明为final。因此，当C试图从B继承时，编译器会给出一个编译错误。</p><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>在一种特殊情况下，派生类虚函数重写可能具有与基类不同的返回类型，但仍然被认为是匹配重写。<code>如果虚函数的返回类型是指针或对类的引用，则重写函数可以返回指针或对派生类的引用</code> (If the return type of a virtual function is a pointer or a reference to a class, override functions can return a pointer or a reference to a derived class.)。这些被称为协变返回类型。这里有一个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// This version of getThis() returns a pointer to a Base class</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Base::getThis()\n"</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class="line"><span class="comment">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Derived::getThis()\n"</span>;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base *b = &amp;d;</span><br><span class="line">d.getThis()-&gt;printType(); <span class="comment">// calls Derived::getThis(), returns a Derived*, calls Derived::printType</span></span><br><span class="line">b-&gt;getThis()-&gt;printType(); <span class="comment">// calls Derived::getThis(), returns a Base*, calls Base::printType</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">called Derived::getThis()</span><br><span class="line">returned a Derived</span><br><span class="line">called Derived::getThis()</span><br><span class="line">returned a Base</span><br></pre></td></tr></table></figure><p>注意，一些较老的编译器(例如Visual Studio 6)不支持协变返回类型。</p><p>关于协变返回类型有一个有趣的注意: c++不能动态选择类型，所以您总是会得到与所调用函数的基本版本相匹配的类型。</p><p>在上面的例子中，我们首先调用d.getThis()。由于d是派生的，因此调用了Derived::getThis()，它返回一个Derived*。然后使用这个Derived*调用非虚函数Derived::printType()。</p><p>有趣的情况是后面着一种。我们调用b-&gt;getThis()。变量b是一个指向派生对象的基指针。Base::getThis()是虚函数，因此调用了Derived::getThis()。虽然Derived::getThis()返回一个Derived*，但是因为函数的基版本返回一个Base*（because base version of the function returns a Base*），返回的Derived*向上转换 (upcast) 为Base*。因此，调用Base::printType()。</p><p>换句话说，在上面的例子中，只有用Derived对象调用getThis()时，才会得到一个Derived* (这个对象首先是作为派生对象输入的)。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B.6 - 新的虚函数控制：override, final, default, delete</title>
      <link href="//blog/2020/05/learncpp-cn-b6-new-virtual-func-control.html"/>
      <url>//blog/2020/05/learncpp-cn-b6-new-virtual-func-control.html</url>
      
        <content type="html"><![CDATA[<h3 id="标识符-override"><a href="#标识符-override" class="headerlink" title="标识符 override"></a>标识符 override</h3><p>当使用派生类时，当您实际上打算重写基类中的函数时，很容易在派生类中无意中创建一个新的虚函数。当您无法正确匹配派生类中的函数原型与基类中的函数原型时，就会发生这种情况。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">float</span>=<span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>=<span class="number">0</span>)</span></span>; <span class="comment">// specifies parameter as int instead of float, treated as new function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>; <span class="comment">// specifies function as non-const, treated as new function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当发生这种情况时，可以很容易地对A()或B()进行函数调用，并期望得到派生版本，但最终得到的却是基本版本。</p><p>当您在Base中向函数添加新参数而忘记更新派生函数的版本时，也很容易出现这种现象。当这种情况发生时，派生中的重写函数不再是重写函数，您的代码将<code>神秘地停止工作 :-)</code>。 这些类型的问题很难发现，因为引发这些问题的变化看起来非常无害。</p><p>c++ 11引入了一个名为override的新标识符，允许显式标记要重写的函数。如果函数不是覆盖的，编译器就会报错。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">float</span>=<span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">D</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>=<span class="number">0</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// compile error because Derived::A(int) does not override Base::A(float)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// compile error because Derived::B() does not override Base::B() const</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// ok!  Derived::C() overrides Base::C()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">D</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// compile error because Derived::D() does not override Base::D() (because Base::D() is not virtual)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然不强制需要使用覆盖 (override) 标识符，但我们强烈建议您使用它，因为它有助于防止意外错误。</p><p>(如果您想知道为什么这是作为标识符 (identifier) 而不是关键字 (keyword) 来实现的，我认为这样做是为了让名称“override”可以在其他上下文中用作普通的变量名。如果它被定义为关键字，那么它将在所有上下文中被保留，这可能会破坏现有的应用程序)</p><h2 id="标识符-final"><a href="#标识符-final" class="headerlink" title="标识符 final"></a>标识符 final</h2><p>有时候，您不希望允许别人重写虚函数，甚至不希望创建派生类。c++ 11添加标识符final来提供此功能。</p><p>下面的例子展示了如何使用final标识符使函数不可重写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// final identifier marks this function as non-overrideable</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>; <span class="comment">// trying to override final function Base::A() will cause a compiler error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>final标识符也可以用在类上，使它们不可继承:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="title">final</span> // <span class="title">final</span> <span class="title">identifier</span> <span class="title">marks</span> <span class="title">this</span> <span class="title">class</span> <span class="title">as</span> <span class="title">non</span>-<span class="title">inheritable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base <span class="comment">// trying to inherit from final class Base will cause a compiler error</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将函数或类设置为final有一些合理的原因。例如，final最常见的用法是确保一个不可变类保持不变。不可变类是一种特殊设计的类，其状态在创建后不能修改。如果没有最终标识符，派生类可能会添加导致类变易变的函数。如果基类为final，则不能将其子类化，这是避免的。</p><p>但是，一般来说，除非你有很好的理由，否则一般应该避免使用final。如果您确实使用了final关键字，请记录原因，因为继承您的代码的人可能并不清楚这一点。</p><h2 id="标识符-default"><a href="#标识符-default" class="headerlink" title="标识符 default"></a>标识符 default</h2><p>在默认情况下，c++将提供一个默认构造函数、复制构造函数、复制赋值操作符(操作符=)和一个析构函数。如果你为你的类提供这些函数的任何一个替代版本，c++将不会提供一个默认版本。但是，在c++ 11中，您现在可以指定希望编译器提供一个默认值。这是通过原型函数 (prototyping the function) 和使用default的说明符:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span> x); <span class="comment">// Custom constructor</span></span><br><span class="line">    Foo() = <span class="keyword">default</span>; <span class="comment">// The compiler will now provide a default constructor for class Foo as well</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>default说明符只能用于具有默认值的函数。</p><h2 id="标识符-delete"><a href="#标识符-delete" class="headerlink" title="标识符 delete"></a>标识符 delete</h2><p>比default说明符更有用的是delete说明符，它可用于禁止定义或调用函数。delete说明符的最佳用途之一是使类不可复制 (uncopyable) :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) = <span class="keyword">delete</span>; <span class="comment">// disallow use of assignment operator</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;) = <span class="keyword">delete</span>; <span class="comment">// disallow copy construction</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以使用delete说明符来确保不调用具有特定参数的成员函数。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">long</span> <span class="keyword">long</span>); <span class="comment">// Can create Foo() with a long long</span></span><br><span class="line">    Foo(<span class="keyword">long</span>) = <span class="keyword">delete</span>; <span class="comment">// But can't create it with anything smaller</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果你尝试用char、short、int或long来调用Foo，这些都会被隐式地转换成long，然后匹配Foo(long)。由于Foo(long)已被删除，编译器将会出错。</p><p>如果你想让你的类只被调用非常具体的数据类型，你可以通过使用一个模板函数来匹配所有没有被明确定义的参数类型，从而关闭所有的隐式转换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">long</span> <span class="keyword">long</span>); <span class="comment">// Can create Foo() with a long long</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">Foo</span><span class="params">(T)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// But can't create it with anything else</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.6 - 纯虚函数、抽象基类和接口类</title>
      <link href="//blog/2020/05/learncpp-cn-126-pure-virtual.html"/>
      <url>//blog/2020/05/learncpp-cn-126-pure-virtual.html</url>
      
        <content type="html"><![CDATA[<h2 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h2><p>到目前为止，我们编写的所有虚函数都有一个主体 (定义) 。但是，c++允许您创建一种特殊的虚函数，称为纯虚函数(或抽象函数)，它完全没有实体! 一个纯虚函数只是作为一个占位符，它将被派生类重新定义。</p><p>要创建一个纯虚函数，而不是为函数定义一个主体，我们只需将函数赋值为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hi"</span>; &#125; <span class="comment">// a normal non-virtual function </span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// a normal virtual function</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// a pure virtual function</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// Compile error: can not set non-virtual functions to 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们向类添加一个纯虚函数时，我们实际上是在说，“实现这个函数取决于派生类”。</p><p>使用纯虚函数有两个主要的结果:首先，任何带有一个或多个纯虚函数的类都变成了一个抽象基类，这意味着它不能被实例化!考虑一下如果我们可以创建一个Base实例会发生什么:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base; <span class="comment">// We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class="line">    base.getValue(); <span class="comment">// what would this do?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有getValue()的定义，那么base.getValue()解析成什么呢?</p><p>其次，任何派生类都必须为这个函数定义一个主体，否则这个派生类也会被认为是一个抽象基类。</p><h3 id="一个纯虚函数的例子"><a href="#一个纯虚函数的例子" class="headerlink" title="一个纯虚函数的例子"></a>一个纯虚函数的例子</h3><p>让我们看一个纯虚函数的例子。在前一课中，我们编写了一个简单的动物基类，并从中派生了一个Cat和一个Dog类。这是我们留下的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通过使构造函数受保护来阻止人们分配Animal类型的对象。然而，这样做有两个问题:</p><ul><li>构造函数仍然可以从派生类中访问，这使得实例化一个动物对象成为可能。</li><li>仍然可以创建不重新定义函数speak()的派生类。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 完，我们忘记了定义Cow类的speak :\</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Betsy says ???</span><br></pre></td></tr></table></figure><p>发生了什么事? 这是因为我们忘记了重新定义函数speak()，因此cow.Speak()解析为anim.speak()，这不是我们想要的。</p><p>更好的解决方法是使用纯虚函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is now a pure virtual function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有几点需要注意。首先，speak()现在是一个纯虚函数。这意味着Animal现在是一个抽象基类，不能被实例化。因此，我们不再需要使构造函数受保护更长时间(尽管它不会造成伤害)。其次，因为我们的Cow类派生自Animal，但是我们没有定义Cow::speak()， Cow也是一个抽象基类。现在，当我们试图编译这段代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会给我们一个警告，因为Cow是一个抽象基类，我们不能创建抽象基类的实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Test.cpp(141):错误C2259: 'Cow':由于以下成员，无法实例化抽象类:</span><br><span class="line">C:Test.cpp(128):参见声明“Cow”</span><br><span class="line">C:\Test.cpp(141): warning C4259: 'const char * thiscall Animal::speak(void)':没有定义纯虚函数</span><br></pre></td></tr></table></figure><p>这告诉我们，只有当Cow为speak()提供了一个主体时，我们才能够实例化Cow。</p><p>让我们继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Moo"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Betsy says Moo</span><br></pre></td></tr></table></figure><p>当我们想要将一个函数放入基类中，但只有派生类知道它应该返回什么时，纯虚函数是有用的。纯虚函数使基类无法实例化，派生类被迫在实例化这些函数之前定义它们。这有助于确保派生类不会忘记重新定义基类所期望的函数。</p><h3 id="带有定义的纯虚函数-Pure-virtual-functions-with-bodies"><a href="#带有定义的纯虚函数-Pure-virtual-functions-with-bodies" class="headerlink" title="带有定义的纯虚函数 (Pure virtual functions with bodies)"></a>带有定义的纯虚函数 (Pure virtual functions with bodies)</h3><p>事实证明，我们可以定义具有定义的纯虚函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// The = 0 means this function is pure virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Animal::speak</span><span class="params">()</span>  <span class="comment">// even though it has a body</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，speak()仍然被认为是一个纯虚函数。尽管我们已经给了它一个定义，但是它的声明带有 “=0”。 Animal仍然被认为是一个抽象基类 (因此不能被实例化)。任何继承自Animal的类都需要为speak()提供自己的定义，否则也会被认为是一个抽象基类。</p><p>当为纯虚函数提供定义时，必须另外单独提供 (而不是内联的) 。</p><p>当您希望基类为函数提供默认实现，但仍然强制任何派生类提供它们自己的实现时，此范例非常有用。但是，如果派生类对基类提供的默认实现感到满意，它可以直接调用基类实现。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is a pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Animal::speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>; <span class="comment">// some default implementation</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragonfly</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dragonfly(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="comment">// this class is no longer abstract because we defined this function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Animal::speak(); <span class="comment">// use Animal's default implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dragonfly <span class="title">dfly</span><span class="params">(<span class="string">"Sally"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dfly.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sally says buzz</span><br></pre></td></tr></table></figure><p>不过这种功能并不常用。</p><h2 id="接口类-Interface-clases"><a href="#接口类-Interface-clases" class="headerlink" title="接口类 (Interface clases)"></a>接口类 (Interface clases)</h2><p>接口类是一个没有成员变量的类，其中所有的函数都是纯虚的!换句话说，该类纯粹是一个定义，没有实际的实现。当您想定义派生类必须实现的功能，但将派生类如何实现该功能的细节完全留给派生类时，接口是有用的。</p><p>接口类通常以”I”开头。下面是一个示例接口类:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IErrorLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">openLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">writeError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">virtual</span> ~IErrorLog() &#123;&#125; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从IErrorLog继承的任何类必须为所有三个函数提供实现，以便实例化。您可以派生一个名为FileErrorLog的类，其中openLog()打开磁盘上的文件，closeLog()关闭文件，writeError()将消息写入文件。您可以派生另一个名为ScreenErrorLog的类，其中openLog()和closeLog()什么都不做，writeError()在屏幕上的弹出消息框中打印消息。</p><p>现在，假设您需要编写一些使用错误日志的代码。如果您编写的代码中直接包含了FileErrorLog或ScreenErrorLog，那么您实际上是在使用这种错误日志 (至少在不重新编写程序的情况下)。例如，下面的函数有效地迫使mySqrt()的调用者使用FileErrorLog，这可能是他们想要的，也可能不是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> value, FileErrorLog &amp;<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>.writeError(<span class="string">"Tried to take square root of value less than 0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现这个函数的一个更好的方法是使用IErrorLog:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> value, IErrorLog &amp;<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>.writeError(<span class="string">"Tried to take square root of value less than 0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，调用者可以传入任何符合IErrorLog接口的类。如果他们希望错误转移到文件中，他们可以传入FileErrorLog的实例。如果他们想让它显示在屏幕上，他们可以传入一个ScreenErrorLog实例。或者，如果他们想做一些您甚至没有想到的事情，比如在出现错误时向某人发送电子邮件，他们可以从IErrorLog (例如EmailErrorLog) 派生一个新类并使用它的一个实例!通过使用IErrorLog，您的函数变得更加独立和灵活。</p><p>不要忘记为您的接口类包含一个虚析构函数，以便在删除指向接口的指针时调用适当的派生析构函数。</p><p>接口类已经变得非常流行，因为它们易于使用、易于扩展和易于维护。事实上，一些现代语言，如Java和c#，已经添加了“interface”关键字，允许程序员直接定义接口类，而不必显式地将所有成员函数标记为抽象。此外，尽管Java (在版本8之前) 和c#不允许您在普通类上使用多重继承，但是它们允许您多重继承任意多的接口。因为接口没有数据和函数体，所以它们避免了很多传统的多重继承问题，同时仍然提供了很大的灵活性。</p><h2 id="纯虚函数和虚表-Virtual-table"><a href="#纯虚函数和虚表-Virtual-table" class="headerlink" title="纯虚函数和虚表 (Virtual table)"></a>纯虚函数和虚表 (Virtual table)</h2><p>抽象类仍然有虚表，因为如果有指向抽象类的指针或引用，仍然可以使用虚表。纯虚函数的虚表条目通常要么包含一个空指针，要么指向一个泛型函数，如果没有被重写，这个泛型函数会输出一个错误 (有时这个函数被命名为_purecall) 。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.3 - 虚的析构函数、虚的赋值和虚的覆盖</title>
      <link href="//blog/2020/05/learncpp-cn-123-virtualization.html"/>
      <url>//blog/2020/05/learncpp-cn-123-virtualization.html</url>
      
        <content type="html"><![CDATA[<h2 id="虚的析构函数、虚的赋值和虚的覆盖"><a href="#虚的析构函数、虚的赋值和虚的覆盖" class="headerlink" title="虚的析构函数、虚的赋值和虚的覆盖"></a>虚的析构函数、虚的赋值和虚的覆盖</h2><h3 id="虚的析构函数（Virtual-destructors）"><a href="#虚的析构函数（Virtual-destructors）" class="headerlink" title="虚的析构函数（Virtual destructors）"></a>虚的析构函数（Virtual destructors）</h3><p>尽管c++为您的类提供了一个默认的析构函数(如果您自己不提供的话)，但有时您会希望提供自己的析构函数 (特别是当类需要释放内存时) 。如果要处理继承，应该始终将析构函数设为虚。考虑下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual (your compiler may warn you about this)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()\n"</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived &#123; <span class="keyword">new</span> Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:如果您编译上面的例子，您的编译器可能会警告您有关非虚拟析构函数 (在本例中是故意这样做的) 。您可能需要禁用将警告作为错误处理的编译器标识 (compiler flag)。</p><p>因为base是一个基指针，所以在删除base时，程序会查看基析构函数是否是虚的。它不是，所以编译器假设它只需要调用基类的析构函数。我们可以从上面的例子的输出中看出这一点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Base()</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">但是，我们确实希望delete函数调用派生的析构函数(它将依次调用Base的析构函数)，否则m_array将不会被删除。我们通过使基的析构函数为虚来做这件事情:</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Base() // note: virtual</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; "Calling ~Base()\n";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Derived: public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int* m_array;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    Derived(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = new int[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    virtual ~Derived() // note: virtual</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; "Calling ~Derived()\n";</span><br><span class="line">        delete[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derived *derived &#123; new Derived(5) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    delete base;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure><blockquote><p>规则: 无论何时处理继承，都应该使任何显式析构函数成为虚函数（ Whenever you are dealing with inheritance, you should make any explicit destructors virtual.）</p></blockquote><p>规则: 无论何时处理继承，都应该使任何显式析构函数成为虚函数。</p><p>与普通的虚成员函数一样，如果基类函数是虚的，则所有派生重写都将被视为虚的，而不管它们是否被指定为虚的。没有必要创建一个空的派生类析构函数来将它标记为虚的。</p><h3 id="虚的赋值-Virtual-assignment"><a href="#虚的赋值-Virtual-assignment" class="headerlink" title="虚的赋值 (Virtual assignment)"></a>虚的赋值 (Virtual assignment)</h3><p>可以使赋值运算符为虚。然而，与析构函数的情况不同，虚拟化析构函数总是一个好主意，但虚拟化赋值操作符实际上打开了一个充满蠕虫的包，并进入了本教程范围之外的一些更高级的主题。因此，为了简单起见，我们建议您暂时不要使用虚的赋值。</p><h3 id="忽略掉虚化（Ignoring-virtualization）"><a href="#忽略掉虚化（Ignoring-virtualization）" class="headerlink" title="忽略掉虚化（Ignoring virtualization）"></a>忽略掉虚化（Ignoring virtualization）</h3><p>我们很少会想要忽略掉函数的虚化。例如，考虑以下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在某些情况下，您可能需要一个指向派生对象的基指针来调用Base::getName()，<br>而不是派生::getName()。要做到这一点，只需使用范围解析操作符:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base &#123; derived &#125;;</span><br><span class="line">    <span class="comment">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能不会经常用到它，但知道它是可能的也许是件好事。</p><h3 id="我们应该让所有析构函数都是虚的吗"><a href="#我们应该让所有析构函数都是虚的吗" class="headerlink" title="我们应该让所有析构函数都是虚的吗?"></a>我们应该让所有析构函数都是虚的吗?</h3><p>这是新程序员常问的问题。如上例所述，如果基类析构函数没有标记为虚函数，那么如果程序员稍后删除指向派生对象的基类指针，程序就有内存泄漏的风险。避免这种情况的一种方法是将所有析构函数标记为虚函数。但是你应该吗? </p><p>说是很容易，这样您以后就可以将任何类用作基类——但是这样做会带来性能损失(向您的类的每个实例添加一个虚指针)。所以你必须平衡成本和你的意图。</p><p>传统观点 (最初由备受推崇的c++大师Herb Sutter提出) 建议避免非虚拟析构函数内存泄漏的情况如下:“基类析构函数应该是以下中的一种，公有并虚拟的，或者是受保护并非虚拟的。”</p><blockquote><p>“A base class destructor should be either public and virtual, or protected and nonvirtual.” </p></blockquote><p>具有受保护析构函数的类不能通过指针进行删除，从而防止在基类具有非虚析构函数时，通过基指针意外删除派生类。不幸的是，这也意味着基类不能通过基类指针删除，这本质上意味着除了派生类之外，该类不能被动态分配或删除。这也排除了对这样的类使用智能指针 (例如std::unique_ptr和std::shared_ptr)，这限制了该规则的有益之处 (我们将在后面的章节中讨论智能指针) 。这也意味着基类不能在堆栈上分配。这真是一堆令人难受的惩罚。</p><p>现在，最终说明符 (final sepcifier) 已经引入到这门语言中，我们的建议如下:</p><ul><li>如果要从类继承，请确保析构函数是虚的。</li><li>如果您不打算从您的类继承，请将您的类标记为final。这将首先防止其他类继承它，而不会对类本身施加任何其他使用上的限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.1 - 指向派生对象的基类的指针和引用</title>
      <link href="//blog/2020/05/learncpp-cn-121-pt-ref-to-derived-object.html"/>
      <url>//blog/2020/05/learncpp-cn-121-pt-ref-to-derived-object.html</url>
      
        <content type="html"><![CDATA[<p>在前一章中，您学习了如何使用继承从现有类派生新类的所有知识。在本章中，我们将重点讨论继承最重要和最强大的方面之一——虚函数。</p><p>但是在我们讨论什么是虚函数之前，让我们先来设置为什么需要它们。</p><p>在构建派生类的章节中，您了解了在创建派生类时，它由多个部分组成: 每个继承的类都有一个部分，它本身也有一个部分。</p><p>以下是一个简单的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValueDoubled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value * <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们创建一个派生对象时，它包含一个基本部分 (首先构造的) 和一个派生部分 (其次构造的) 。请记住，继承意味着两个类之间存在一个<code>is-a</code>关系。因为派生的<code>是一个</code>基，所以派生的包含基部分是合适的。</p><h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><h3 id="指针，引用，和派生类"><a href="#指针，引用，和派生类" class="headerlink" title="指针，引用，和派生类"></a>指针，引用，和派生类</h3><p>我们可以设置派生指针和引用的派生对象，这应该是相当直观的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived &amp;rDerived&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rDerived is a "</span> &lt;&lt; rDerived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rDerived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived *pDerived&#123; &amp;derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pDerived is a "</span> &lt;&lt; pDerived-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pDerived-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived is a Derived and has value 5</span><br><span class="line">rDerived is a Derived and has value 5</span><br><span class="line">pDerived is a Derived and has value 5</span><br></pre></td></tr></table></figure><p>然而，由于Derived有一个基部分，一个更有趣的问题是c++是否会让我们设置一个基指针或引用到一个派生的对象。事实证明，我们可以!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// These are both legal!</span></span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    Base *pBase&#123; &amp;derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rBase.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pBase is a "</span> &lt;&lt; pBase-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pBase-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived is a Derived and has value 5</span><br><span class="line">rBase is a Base and has value 5</span><br><span class="line">pBase is a Base and has value 5</span><br></pre></td></tr></table></figure><p>这个结果应该不是你想要的。</p><p>因为rBase和pBase是一个基引用和指针，所以它们只能看到基的成员(或者基继承的任何类)。因此，即使派生::getName()的阴影(隐藏)基::getName()的派生对象，基指针/引用不能看到Derived::getName()。因此，它们调用Base::getName()，这就是为什么rBase和pBase报告说它们是基而不是派生的。</p><p>注意，这也意味着不可能使用rBase或pBase调用Derived::getValueDoubled()。他们看不到任何衍生的东西。</p><p>下面是另一个稍微复杂一点的例子，我们将在下节课中继续学习:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : m_name&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cat is named "</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">", and it says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Dog dog&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dog is named "</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">", and it says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Animal *pAnimal&#123; &amp;cat &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span> &lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    pAnimal = &amp;dog;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span> &lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat is named Fred, and it says Meow</span><br><span class="line">dog is named Garbo, and it says Woof</span><br><span class="line">pAnimal is named Fred, and it says ???</span><br><span class="line">pAnimal is named Garbo, and it says ???</span><br></pre></td></tr></table></figure><p>我们在这里看到了同样的问题。因为pAnimal是一个动物类的指针，所以它只能看到类的Animal部分。因此，pAnimal-&gt;speak()调用Animal::speak()，而不是Dog:: speak()或Cat::speak()函数。</p><h3 id="为什么我们要使用指向基类的指针和引用"><a href="#为什么我们要使用指向基类的指针和引用" class="headerlink" title="为什么我们要使用指向基类的指针和引用"></a>为什么我们要使用指向基类的指针和引用</h3><p>首先，假设您想编写一个函数来打印动物的名字和声音。如果不使用指向基类的指针，就必须使用重载函数来编写它，如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Cat &amp;cat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Dog &amp;dog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当然不难，但是想想如果我们有30种不同的动物而不是2种，会发生什么？你必须写30个几乎相同的函数! 另外，如果你添加了一种新的动物，你也必须为它写一个新的函数。而考虑到唯一真正的区别是参数的类型，重写所所有的函数真是一个巨大的时间浪费。</p><p>然而，因为猫和狗是从动物衍生出来的，猫和狗有一个动物的部分。因此，我们应该能够这样做是有意义的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Animal &amp;rAnimal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rAnimal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; rAnimal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This would let us pass in any class derived from Animal, even ones that we created after we wrote the function! Instead of one function per derived class, we get one function that works with all classes derived from Animal!</p><p>The problem is, of course, that because rAnimal is an Animal reference, rAnimal.speak() will call Animal::speak() instead of the derived version of speak().</p><p>Second, let’s say you had 3 cats and 3 dogs that you wanted to keep in an array for easy access. Because arrays can only hold objects of one type, without a pointer or reference to a base class, you’d have to create a different array for each derived type, like this:<br>这将允许我们传入任何派生自Animal的类，甚至是我们在编写函数之后创建的类! <code>不是每个派生类都有一个函数，而是有一个函数可以处理所有从Animal派生的类</code>!</p><p>当然，问题是，因为rAnimal是一个动物类的引用，所以rAnimal.speak()将调用Animal::speak()，而不是speak()的派生版本。</p><p>其次，假设您有3只猫和3只狗，您希望将它们放在一个数组中，以便于访问。因为数组只能保存一种类型的对象，没有指针或对基类的引用，所以必须为每个派生类型创建不同的数组，如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cats[]&#123; &#123; <span class="string">"Fred"</span> &#125;, &#123; <span class="string">"Misty"</span> &#125;, &#123; <span class="string">"Zeke"</span> &#125; &#125;;</span><br><span class="line">    Dog dogs[]&#123; &#123; <span class="string">"Garbo"</span> &#125;, &#123; <span class="string">"Pooky"</span> &#125;, &#123; <span class="string">"Truffle"</span> &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cat : cats)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;dog : dogs)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，考虑一下如果你有30种不同的动物会发生什么。你需要30个数组，每种动物一个! 然而，因为猫和狗都来自于动物，我们做这样的事情是有道理的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">    Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">    Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</span></span><br><span class="line">    Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> animal : animals)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译和执行时，不幸的是，数组“animals”的每个元素都是指向动物的指针，这意味着animals[3]-&gt;speak()将调用Animal::speak()，而不是我们想要的speak()的派生类版本。</p><p>虽然这两种技术都可以节省我们大量的时间和精力，但它们都有相同的问题。指向基类的指针或引用调用函数的基版本，而不是派生版本。如果有什么方法可以让这些基指针调用函数的派生版本而不是基版本就好了……</p><p>想猜猜虚函数是干什么的吗? :)</p><h2 id="小测！Quiz-time"><a href="#小测！Quiz-time" class="headerlink" title="小测！Quiz time"></a>小测！Quiz time</h2><h3 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h3><p>上面的Animal/Cat/Dog示例并不像我们希望的那样工作，因为指向Animal类的引用或指针无法访问speak()的派生版本，而speak()需要为猫或狗返回正确的值。解决这个问题的一种方法是将speak()函数返回的数据作为动物基类的一部分进行访问(非常类似于通过成员m_name访问动物的名称)。</p><p>通过向名为m_speak的动物添加一个新成员来更新上面课程中的动物、猫和狗类。适当的初始化它, 以便以下程序能正常工作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">    Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">    Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</span></span><br><span class="line">    Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> animal : animals)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="built_in">std</span>::string_view m_speak;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="built_in">std</span>::string_view speak)</span><br><span class="line">        : m_name&#123; name &#125;, m_speak&#123; speak &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Animal(<span class="keyword">const</span> Animal&amp;) = <span class="keyword">delete</span>; <span class="comment">// to prevent shallow copies</span></span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp;) = <span class="keyword">delete</span>; <span class="comment">// to prevent shallow copies</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_speak; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name, <span class="string">"Meow"</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name, <span class="string">"Woof"</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">    Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">    Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</span></span><br><span class="line">    Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> animal : animals)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 还可以将m_speak设置为std::string，但是这样做的缺点是每个动物都包含一个多余的“speak”字符串副本，而且animals数组的构造将花费更长的时间，因为创建std::string的深层拷贝比复制std::string_view要慢。</p></blockquote><h3 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h3><p>思考一个问题：为什么上述的解决方案并不好？</p><p>提示: 考虑一下猫和狗的未来状态，我们想在更多方面区分猫和狗。<br>提示: 考虑需要在初始化时设置成员的方式对您的限制。</p><p>答案：</p><blockquote><p>当前的解决方案不是最优的<br>(1) 因为我们需要为每种区分Cat和Dog的方法添加一个成员。随着时间的推移，我们的动物类可能会变得非常庞大，而且复杂!<br>(2) 只有在初始化时可以确定基类成员时，此解决方案才有效。例如，如果speak()为每个动物返回一个随机结果 (例如:calling Dog::speak()可以返回“woof”、“arf”或“yip”)，这种解决方案就会开始变得笨拙并崩溃。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.2 - 虚函数和多态</title>
      <link href="//blog/2020/05/learncpp-cn-122-virtual-function.html"/>
      <url>//blog/2020/05/learncpp-cn-122-virtual-function.html</url>
      
        <content type="html"><![CDATA[<p>在前面关于派生对象的基类的指针和引用的一节课中，我们看了一些例子，其中使用基类的指针或引用 (base pointer or reference) 有可能简化代码。但是，在每种情况下，我们都会遇到这样的问题: 基指针或引用只能调用函数的基版本，而不能调用派生版本 (base pointer or reference was only able to call the base version of a function, not a derived version) 。</p><p>下面是这种行为的一个简单例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的打印结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rBase is a Base</span><br></pre></td></tr></table></figure><p>因为rBase是一个基引用，所以它调用Base::getName()，即使它实际上引用了派生对象的基部分 (it’s actually referencing the Base portion of a Derived object)。</p><p>在这节课中，我们将展示如何使用虚函数来解决这个问题。</p><h2 id="虚函数和多态-Virtual-functions-and-polymorphism"><a href="#虚函数和多态-Virtual-functions-and-polymorphism" class="headerlink" title="虚函数和多态 (Virtual functions and polymorphism)"></a>虚函数和多态 (Virtual functions and polymorphism)</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>虚函数是一种特殊类型的函数，当调用虚函数时，解析为存在于基类和派生类之间的函数的最派生版本 (resolves to the most-derived version of the function that exists between the base and derived class). 这种能力称为多态性。如果派生函数具有相同的签名(名称、参数类型以及是否为const)并返回类型作为该函数的基本版本，则将该函数视为匹配。这样的函数称为覆盖 (overrides) .</p><p>要使函数成为虚函数，只需将“virtual”关键字放在函数声明之前。</p><p>以下是一个虚函数的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;  <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rBase is a Derived</span><br></pre></td></tr></table></figure><p>因为rBase是对派生对象的基部分的引用，所以在计算rBase.getName()时，它通常会解析为Base::getName()。但是，Base::getName()是虚的，它告诉程序去查看在Base和Derived之间是否还有其他派生版本的函数可用。在本例中，它将解析为Derived::getName()!</p><p>更复杂的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C c;</span><br><span class="line">A &amp;rBase&#123; c &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看它是如何工作的。首先，我们实例化一个C类对象 (instantiate a C class object). rBase是一个引用，我们将其设置为引用C对象的A部分。最后，我们调用rBase.getName()。rBAse.getName()的计算结果是A::getName()。但是，A::getName()是虚的，因此编译器将调用A和C之间最派生的匹配。在本例中，就是C::getName()。注意，它不会调用D::getName()，因为我们的原始对象是C，而不是D，所以只考虑A和C之间的函数。</p><p>因此，我们的程序输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rBase is a C</span><br></pre></td></tr></table></figure><p>让我们再看一看我们在上节课中学习的动物例子。这是原始类，以及一些测试代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : m_name&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Dog dog&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    report(cat);</span><br><span class="line">    report(dog);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fred says ???</span><br><span class="line">Garbo says ???</span><br></pre></td></tr></table></figure><p>下面是一个把speak()函数变成虚函数的等价类:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : m_name&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">        : Animal&#123; name &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Dog dog&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    report(cat);</span><br><span class="line">    report(dog);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fred says Meow</span><br><span class="line">Garbo says Woof</span><br></pre></td></tr></table></figure><p>它按预想的方式工作了！</p><p>当解析Animal .speak()时，程序注意到Animal::speak()是一个虚函数。在animal引用Cat对象的animal部分的情况下，程序会查看animal和Cat之间的所有类，看看能否找到更派生的函数。在这种情况下，它找到Cat::speak()。在动物引用Dog对象的动物部分的情况下，程序将函数调用解析为Dog::speak()。</p><p>注意，我们没有将Animal::getName()设为虚。这是因为在任何派生类中都不会重写getName()，因此没有必要这样做。</p><p>类似地，以下的例子也会按预想的方式工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</span></span><br><span class="line">Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *animal : animals)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fred says Meow</span><br><span class="line">Garbo says Woof</span><br><span class="line">Misty says Meow</span><br><span class="line">Pooky says Woof</span><br><span class="line">Truffle says Woof</span><br><span class="line">Zeke says Meow</span><br></pre></td></tr></table></figure><p>尽管这两个例子只使用了Cat和Dog，但是我们从Animal派生的任何其他类也可以使用我们的report()函数和Animal数组，无需进一步修改!这可能是虚函数的最大好处——能够以这样一种方式构造代码，即新派生的类将自动使用旧代码，而无需修改!</p><p>警告: 为了使用派生类函数，<code>派生类函数的签名必须与基类虚函数的签名完全匹配</code>。如果派生类函数具有不同的参数类型，程序可能仍然可以很好地编译，但是虚拟函数不会按照预期解析。</p><blockquote><p>Warning: The signature of the derived class function must <code>exactly match</code> the signature of the base class virtual function in order for the derived class function to be used. If the derived class function has different parameter types, the program will likely still compile fine, but the virtual function will not resolve as intended.</p></blockquote><h3 id="使用virtual关键字"><a href="#使用virtual关键字" class="headerlink" title="使用virtual关键字"></a>使用virtual关键字</h3><p><code>如果一个函数被标记为虚函数，那么所有匹配覆盖也被认为是虚函数</code>，即使它们没有显式地标记为虚函数。但是，在派生函数上使用关键字virtual并没有什么害处，它可以提醒您，该函数是一个虚函数，而不是一个普通的函数。因此，在派生类中对虚拟化函数使用virtual关键字通常是一个好主意，尽管这并不是严格必需的。</p><h3 id="虚函数的返回类型"><a href="#虚函数的返回类型" class="headerlink" title="虚函数的返回类型"></a>虚函数的返回类型</h3><p>在正常情况下，覆盖虚函数时必须要匹配虚函数声明的返回类型。考虑下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">6.78</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，Derived::getValue()不被认为是Base::getValue()的匹配覆盖 (它被认为是一个完全独立的函数) 。</p><h3 id="不从构造函数或析构函数调用虚函数"><a href="#不从构造函数或析构函数调用虚函数" class="headerlink" title="不从构造函数或析构函数调用虚函数"></a>不从构造函数或析构函数调用虚函数</h3><p>这是另一个让不知情的新程序员头痛的陷阱。我们不应该从构造函数或析构函数调用虚函数。为什么呢?</p><p>请记住，在创建派生类时，首先构造基部分。如果您要从基构造函数调用虚函数，而类的派生部分还没有创建，那么它将无法调用函数的派生版本，因为没有派生对象供派生函数使用。在c++中，它将调用基版本。</p><p>析构函数也存在类似的问题。如果在基类析构函数中调用虚函数，它将始终解析为函数的基类版本，因为类的派生部分已经被销毁。</p><blockquote><p>Rule: Never call virtual functions from constructors or destructors</p></blockquote><h3 id="虚函数的缺点"><a href="#虚函数的缺点" class="headerlink" title="虚函数的缺点"></a>虚函数的缺点</h3><p>既然大多数情况下你希望函数是虚的，为什么不让所有的函数都是虚的呢?答案是因为它的效率很低——解析一个虚函数调用要比解析一个常规函数调用花费更长的时间。此外，编译器还必须为每个具有一个或多个虚函数的类对象分配一个额外的指针。我们将在本章以后的课程中更多地讨论这个问题。</p><h2 id="小测！Quiz-time"><a href="#小测！Quiz-time" class="headerlink" title="小测！Quiz time"></a>小测！Quiz time</h2><p>下列程序打印什么?这个练习是通过检查来完成的，而不是用编译器编译示例。</p><h3 id="a"><a href="#a" class="headerlink" title="(a)"></a>(a)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Note: no getName() function here</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    A &amp;rBase&#123; c &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>B. </p></blockquote><p>rBase是一个指向C对象的引用。通常情况下，rBase.getName()会调用A::getName()，但是A::getName()是虚的，所以它调用的是A和c之间最派生的匹配函数，即B::getName()，它输出B。</p><h3 id="b"><a href="#b" class="headerlink" title="(b)"></a>(b)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    B &amp;rBase&#123; c &#125;; <span class="comment">// note: rBase is a B this time</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>C. </p></blockquote><p>这非常简单，因为C::getName()是类B和C之间最派生 (most-derived) 的匹配调用。</p><h3 id="c"><a href="#c" class="headerlink" title="(c)"></a>(c)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// note: no virtual keyword</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    A &amp;rBase&#123; c &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>A. </p></blockquote><p>因为A的getName函数不是虚的，所以当调用rBase.getName()时，调用A::getName()。</p><h3 id="d"><a href="#d" class="headerlink" title="(d)"></a>(d)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// note: no virtual keyword in B, C, and D</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    B &amp;rBase&#123; c &#125;; <span class="comment">// note: rBase is a B this time</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>C. </p></blockquote><p>虽然getName在B和C中没有标记为虚函数，但是A::getName()是虚函数，B::getName()和C::getName()是重写函数。因此，B::getName()和C::getName()被隐式地标记为了虚函数 (<code>implicitly virtual</code>)，因此对rBase.getName()的调用解析为C::getName()，而不是B::getName()。</p><h3 id="e"><a href="#e" class="headerlink" title="(e)"></a>(e)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Note: Functions in B, C, and D are non-const.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    A &amp;rBase&#123; c &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>A. </p></blockquote><p>这个有点复杂。rBase是A对C对象的一个引用，因此rBase.getName()通常会调用A::getName()。但是，A::getName()是虚的，因此它在A和c之间调用函数的最派生版本，即A::getName()。因为B::getName()和c::getName()不是常量，它们“不被认为是覆盖”! 所以这个程序会打印“A”。</p><h3 id="f"><a href="#f" class="headerlink" title="(f)"></a>(f)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getName(); &#125; <span class="comment">// note addition of constructor</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C c;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案:</p><blockquote><p>A.</p></blockquote><p>另一个有点棘手的问题哟。当我们创建一个C对象时，首先构造A部分。当构造函数被调用时，它会调用虚函数getName()。因为类的B和C部分还没有设置，所以解析为A::getName()。</p>]]></content>
      
      
      <categories>
          
          <category> learncpp-cn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> polymorphism </tag>
            
            <tag> virtual function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown TEST</title>
      <link href="//blog/2020/05/2020-05-27-markdown-test.html"/>
      <url>//blog/2020/05/2020-05-27-markdown-test.html</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown是一种轻量级的「标记语言」</strong></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h2 id="MdEditor是一个在线编辑Markdown文档的编辑器"><a href="#MdEditor是一个在线编辑Markdown文档的编辑器" class="headerlink" title="MdEditor是一个在线编辑Markdown文档的编辑器"></a>MdEditor是一个在线编辑Markdown文档的编辑器</h2><p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p><blockquote><p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p></blockquote><p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href="https://github.com/pandao/editor.md" target="_blank" rel="noopener" title="Editor.md">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p><p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p><h2 id="MdEditor的功能列表演示"><a href="#MdEditor的功能列表演示" class="headerlink" title="MdEditor的功能列表演示"></a>MdEditor的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em>      <em>斜体字</em></p><p><strong>粗体</strong>  <strong>粗体</strong></p><p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br><a href="https://www.mdeditor.com/" target="_blank" rel="noopener" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:test.test@gmail.com">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com">www@vip.qq.com</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello world."</span>)</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">"Microsoft Yahei"</span>, Tahoma, <span class="string">"Hiragino Sans GB"</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" target="_blank" rel="noopener" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png" alt=""></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li><input checked="" disabled="" type="checkbox"> GFM task list 1</li><li><input checked="" disabled="" type="checkbox"> GFM task list 2</li><li><input disabled="" type="checkbox"> GFM task list 3<ul><li><input disabled="" type="checkbox"> GFM task list 3-1</li><li><input disabled="" type="checkbox"> GFM task list 3-2</li><li><input disabled="" type="checkbox"> GFM task list 3-3</li></ul></li><li><input disabled="" type="checkbox"> GFM task list 4<ul><li><input disabled="" type="checkbox"> GFM task list 4-1</li><li><input disabled="" type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th align="right">Value</th></tr></thead><tbody><tr><td>Computer</td><td align="right">$1600</td></tr><tr><td>Phone</td><td align="right">$12</td></tr><tr><td>Pipe</td><td align="right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><p>18&ordm;C  &quot;  &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li><input checked="" disabled="" type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li><input checked="" disabled="" type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li><li><input disabled="" type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li><input disabled="" type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li><input disabled="" type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li><input disabled="" type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) &#x3D; \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作手册|命令速查表</title>
      <link href="//blog/2020/05/2016-02-20-git-guide.html"/>
      <url>//blog/2020/05/2016-02-20-git-guide.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。<br>本文分为以下几个部分：</p><ol><li>Git与SVN差异</li><li>Git常用命令</li><li>Git进阶指南</li></ol><h2 id="Git与SVN差异"><a href="#Git与SVN差异" class="headerlink" title="Git与SVN差异"></a>Git与SVN差异</h2><p>Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。</p><p>Git 和 SVN 思想最大的差别有四个：</p><ul><li>去中心化</li><li>直接记录快照，而非差异</li><li>不一样的分支概念</li><li>三个文件状态</li></ul><p><strong>去中心化</strong></p><p>Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西，所有的数据都在本地，不存在谁是中心</p><p><img src="/image/git.png" alt=""></p><p>图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。</p><p><strong>直接记录快照，而非差异</strong></p><p>Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：</p><p>SVN：</p><p><img src="/image/svn.png" alt=""></p><p>Git:</p><p><img src="/image/gitgit.png" alt=""></p><p>Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。</p><p><strong>不一样的分支概念</strong></p><p>Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。</p><p><strong>三个文件状态</strong></p><p>在Git中文件有三种状态：</p><ul><li>已提交（committed）：该文件被安全地保存在了本地数据库</li><li>已修改（modified）：修改了某个文件，但还没有保存</li><li>已暂存（staged）：把已修改的文件放下下次保存的清单中</li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:</p><pre><code>$ git clone ssh://user@domain.com/repo.git</code></pre><p>创建一个新的本地仓库:</p><pre><code>$ git init</code></pre><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：</p><pre><code>$ git status</code></pre><p>显示与上次提交版本文件的不同：</p><pre><code>$ git diff</code></pre><p>把当前所有修改添加到下次提交中：</p><pre><code>$ git add</code></pre><p>把对某个文件的修改添加到下次提交中：</p><pre><code>$ git add -p &lt;file&gt;</code></pre><p>提交本地的所有修改：</p><pre><code>$ git commit -a</code></pre><p>提交之前已标记的变化：</p><pre><code>$ git commit</code></pre><p>附加消息提交：</p><pre><code>$ git commit -m &apos;message here&apos;</code></pre><p>提交，并将提交时间设置为之前的某个日期:</p><pre><code>git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot;</code></pre><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><p>请勿修改已发布的提交记录!</p><pre><code>$ git commit --amend</code></pre><p>把当前分支中未提交的修改移动到其他分支</p><pre><code>git stashgit checkout branch2git stash pop</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>从当前目录的所有文件中查找文本内容：</p><pre><code>$ git grep &quot;Hello&quot;</code></pre><p>在某一版本中搜索文本：</p><pre><code>$ git grep &quot;Hello&quot; v2.5</code></pre><h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</p><pre><code>$ git log</code></pre><p>显示所有提交（仅显示提交的hash和message）：</p><pre><code>$ git log --oneline</code></pre><p>显示某个用户的所有提交：</p><pre><code>$ git log --author=&quot;username&quot;</code></pre><p>显示某个文件的所有修改：</p><pre><code>$ git log -p &lt;file&gt;</code></pre><p>谁，在什么时间，修改了文件的什么内容：</p><pre><code>$ git blame &lt;file&gt;</code></pre><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有的分支：</p><pre><code>$ git branch</code></pre><p>切换分支：</p><pre><code>$ git checkout &lt;branch&gt;</code></pre><p>创建并切换到新分支:</p><pre><code>$ git checkout -b &lt;branch&gt;</code></pre><p>基于当前分支创建新分支：</p><pre><code>$ git branch &lt;new-branch&gt;</code></pre><p>基于远程分支创建新的可追溯的分支：</p><pre><code>$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</code></pre><p>删除本地分支:</p><pre><code>$ git branch -d &lt;branch&gt;</code></pre><p>给当前版本打标签：</p><pre><code>$ git tag &lt;tag-name&gt;</code></pre><h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出当前配置的远程端：</p><pre><code>$ git remote -v</code></pre><p>显示远程端的信息：</p><pre><code>$ git remote show &lt;remote&gt;</code></pre><p>添加新的远程端：</p><pre><code>$ git remote add &lt;remote&gt; &lt;url&gt;</code></pre><p>下载远程端版本，但不合并到HEAD中：</p><pre><code>$ git fetch &lt;remote&gt;</code></pre><p>下载远程端版本，并自动与HEAD版本合并：</p><pre><code>$ git remote pull &lt;remote&gt; &lt;url&gt;</code></pre><p>将远程端版本合并到本地版本中：</p><pre><code>$ git pull origin master</code></pre><p>将本地版本发布到远程端：</p><pre><code>$ git push remote &lt;remote&gt; &lt;branch&gt;</code></pre><p>删除远程端分支：</p><pre><code>$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)或git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</code></pre><p>发布标签:</p><pre><code>$ git push --tags</code></pre><h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：</p><pre><code>$ git merge &lt;branch&gt;</code></pre><p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!</p><pre><code>$ git rebase &lt;branch&gt;</code></pre><p>退出重置:</p><pre><code>$ git rebase --abort</code></pre><p>解决冲突后继续重置：</p><pre><code>$ git rebase --continue</code></pre><p>使用配置好的merge tool 解决冲突：</p><pre><code>$ git mergetool</code></pre><p>在编辑器中手动解决冲突后，标记文件为已解决冲突</p><pre><code>$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt;</code></pre><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：</p><pre><code>$ git reset --hard HEAD</code></pre><p>移除缓存区的所有文件（i.e. 撤销上次git add）:</p><pre><code>$ git reset HEAD</code></pre><p>放弃某个文件的所有本地修改：</p><pre><code>$ git checkout HEAD &lt;file&gt;</code></pre><p>重置一个提交（通过创建一个截然不同的新提交）</p><pre><code>$ git revert &lt;commit&gt;</code></pre><p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</p><pre><code>$ git reset --hard &lt;commit&gt;</code></pre><p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</p><pre><code>$ git reset &lt;commit&gt;</code></pre><p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</p><pre><code>$ git reset --keep &lt;commit&gt;</code></pre><h2 id="Git进阶指南"><a href="#Git进阶指南" class="headerlink" title="Git进阶指南"></a>Git进阶指南</h2><h3 id="问：如何修改-origin-仓库信息？"><a href="#问：如何修改-origin-仓库信息？" class="headerlink" title="问：如何修改 origin 仓库信息？"></a>问：如何修改 origin 仓库信息？</h3><h4 id="1、添加-origin-仓库信息"><a href="#1、添加-origin-仓库信息" class="headerlink" title="1、添加 origin 仓库信息"></a>1、添加 origin 仓库信息</h4><pre><code>git remote add origin &lt;git仓库地址&gt;</code></pre><h4 id="2、查看-origin-仓库信息"><a href="#2、查看-origin-仓库信息" class="headerlink" title="2、查看 origin 仓库信息"></a>2、查看 origin 仓库信息</h4><pre><code># 以下三种方式均可git config get --remote.origin.urlgit remote -vgit remote show origin</code></pre><h4 id="3、删除-origin-仓库信息"><a href="#3、删除-origin-仓库信息" class="headerlink" title="3、删除 origin 仓库信息"></a>3、删除 origin 仓库信息</h4><pre><code>git remote rm origin</code></pre><h3 id="问：如何配置-git-ssh-keys-？"><a href="#问：如何配置-git-ssh-keys-？" class="headerlink" title="问：如何配置 git ssh keys ？"></a>问：如何配置 git ssh keys ？</h3><p>在本地生成 ssh 私钥 / 公钥 文件<br>将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台<br>测试 git ssh 连接是否成功<br>接下来以添加 github ssh keys 为例，请注意替换 github 文件名。</p><p>注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。</p><pre><code># 运行以下命令，一直回车，文件名可随意指定ssh-keygen -t rsa -b 4096 -C &quot;kaiye@macbook&quot; -f ~/.ssh/github# 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychainssh-add -K ~/.ssh/github# 将 pub 公钥的内容粘贴到线上网站的后台cat ~/.ssh/github.pub# 测试 git ssh 是否连接成功ssh -T git@github.com</code></pre><h3 id="问：如何撤销修改？"><a href="#问：如何撤销修改？" class="headerlink" title="问：如何撤销修改？"></a>问：如何撤销修改？</h3><p>  修改包含四种情况，需单独区分。</p><h4 id="1、新建的文件和目录，且从未提交至版本库"><a href="#1、新建的文件和目录，且从未提交至版本库" class="headerlink" title="1、新建的文件和目录，且从未提交至版本库"></a>1、新建的文件和目录，且从未提交至版本库</h4><p>  此类文件的状态为 Untracked files ，撤销方法如下：</p><pre><code>git clean -fd .</code></pre><p>其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。</p><h4 id="2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）"><a href="#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）" class="headerlink" title="2、提交过版本库，但未提交至暂存区的文件（未执行 git add）"></a>2、提交过版本库，但未提交至暂存区的文件（未执行 git add）</h4><p>  此类文件的状态为<code>Changes not staged for commit</code>，撤销方法：</p><pre><code>git checkout .</code></pre><h4 id="3、已提交至暂存区的文件"><a href="#3、已提交至暂存区的文件" class="headerlink" title="3、已提交至暂存区的文件"></a>3、已提交至暂存区的文件</h4><p>  此类文件的状态为 Changes to be committed，撤销方法：</p><pre><code>git reset .</code></pre><p>执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。</p><h4 id="4、已提交至版本库（执行了-git-commit）"><a href="#4、已提交至版本库（执行了-git-commit）" class="headerlink" title="4、已提交至版本库（执行了 git commit）"></a>4、已提交至版本库（执行了 git commit）</h4><p>  每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：</p><pre><code>git loggit reset &lt;版本号&gt;</code></pre><p>如果需要「回滚至上一次提交」，可直接使用以下命令：</p><pre><code>git reset head~1</code></pre><p>执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。</p><h4 id="5、如果回滚了之后又不想回滚了怎么办？"><a href="#5、如果回滚了之后又不想回滚了怎么办？" class="headerlink" title="5、如果回滚了之后又不想回滚了怎么办？"></a>5、如果回滚了之后又不想回滚了怎么办？</h4><p>  如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。</p><p>  如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。</p><h3 id="问：遇到冲突了怎么解决？"><a href="#问：遇到冲突了怎么解决？" class="headerlink" title="问：遇到冲突了怎么解决？"></a>问：遇到冲突了怎么解决？</h3><p>  两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。</p><h4 id="1、最快的办法"><a href="#1、最快的办法" class="headerlink" title="1、最快的办法"></a>1、最快的办法</h4><p>  大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。</p><pre><code># 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方git checkout --ours &lt;文件名&gt; # 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分 git checkout --theirs &lt;文件名&gt;# 标记为解决状态加入暂存区git add &lt;文件名&gt;</code></pre><h4 id="2、最通用的办法"><a href="#2、最通用的办法" class="headerlink" title="2、最通用的办法"></a>2、最通用的办法</h4><p>  用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。</p><p>  在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。</p><h4 id="3、最好的习惯"><a href="#3、最好的习惯" class="headerlink" title="3、最好的习惯"></a>3、最好的习惯</h4><p>  有三个好的习惯，可以减少代码的冲突：<br> 在开始修改代码前先 git pull 一下；<br>  将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；<br>  通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。</p><h4 id="4、最复杂的情况"><a href="#4、最复杂的情况" class="headerlink" title="4、最复杂的情况"></a>4、最复杂的情况</h4><p>  如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。</p><p>  它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。</p><p>  rebase 大概的操作步骤如下：</p><pre><code># 将当前分支的版本追加到从远程 pull 回来的节点之后git pull --rebase# 若发生冲突，则按以上其他方法进行解决，解决后继续git rebase --continue# 直到所有冲突得以解决，待项目最后上线前再执行git push origin# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可git rebase --skip</code></pre><h3 id="问：如何在不提交修改的前提下，执行-pull-merge-等操作？"><a href="#问：如何在不提交修改的前提下，执行-pull-merge-等操作？" class="headerlink" title="问：如何在不提交修改的前提下，执行 pull / merge 等操作？"></a>问：如何在不提交修改的前提下，执行 pull / merge 等操作？</h3><p>  有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。</p><p>  这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。</p><p>  以下是 git stash 常用命令：</p><pre><code># 查看 stash 队列中已暂存了多少 WIPgit stash list# 恢复上一次的 WIP 状态，并从队列中移除git stash pop# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失git stash# 恢复指定编号的 WIP，同时从队列中移除git stash pop stash@{num}# 恢复指定编号的 WIP，但不从队列中移除git stash apply stash@{num}</code></pre><h3 id="问：如何在-git-log-中查看修改的文件列表？"><a href="#问：如何在-git-log-中查看修改的文件列表？" class="headerlink" title="问：如何在 git log 中查看修改的文件列表？"></a>问：如何在 git log 中查看修改的文件列表？</h3><p>  默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。</p><pre><code>git log --name-status --oneline</code></pre><p>  每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：</p><pre><code>git config --global alias.ls &apos;log --name-status --oneline --graph&apos;</code></pre><p>  运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。</p><pre><code>git config --global alias.st &apos;status --porcelain&apos;</code></pre><p>  更多 git log 参数，可通过 git help log 查看手册。</p><p>  如果是看上一次提交的版本日志，直接运行 git show 即可。</p><p>  此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。</p><h3 id="问：git-submodule-update-时出错怎么解决？"><a href="#问：git-submodule-update-时出错怎么解决？" class="headerlink" title="问：git submodule update 时出错怎么解决？"></a>问：git submodule update 时出错怎么解决？</h3><p>  例如，在执行 git submodule update 时有以下错误信息：</p><blockquote><p>fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5<br>Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’</p></blockquote><p>  在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit了新的版本「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。</p><p>  解决方法，在电脑A上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>  设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可</p><pre><code>git push origin master -u </code></pre><p>  支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）</p><pre><code>git config core.quotepath off</code></pre><p>  常用的打 tag 操作，更多请查看《Git 基础 - 打标签》</p><pre><code># 列出所有本地 taggit tag   # 本地新增一个 tag，推送至 origin 服务器git tag -a v1.0.0 -m &apos;tag description&apos;git push origin v1.0.0# 删除本地与 origin taggit tag -d v1.0.0git push origin --delete v1.0.0</code></pre><p>  使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：</p><pre><code># 新建分支 branch1，并切换过去git checkout -b branch1# 查看所有本地与远程分支git branch -a# 修改完成后，切换回 master 分支，将 branch1 分支合并进来git checkout mastergit merge branch1# 删除已完成合并的分支 branch1git branch -d branch1</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>Pro Git 简体中文版</li><li>Git权威指南</li><li>命令行man手册</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//blog/2020/05/2018-01-01-hello-world.html"/>
      <url>//blog/2020/05/2018-01-01-hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
